[[_rebasing]]
=== Ребазирање

(((rebasing)))
У програму Гит постоје два основна начина за интеграцију промена из једне гране у другу: `merge` и `rebase`.
У овом одељку ћете научити шта је ребазирање, како се ради, зашто је то прилично добар алат, као и када треба а када не треба да га користите.

==== Основно ребазирање

Ако погледате ранији пример из <<_basic_merging>>, видећете да сте разгранали свој рад и направили комитове на две различите гране.

.Једноставна разграната историја
image::images/basic-rebase-1.png[Једноставна разграната историја]

Као што смо већ раније показали, најлакши начин да интегришете гране је помоћу команде `merge`.
Она ће урадити троструко спајање између два последња снимка са грана (`C3` и `C4`) и њиховог најсвежијег заједничког претка (`C2`), стварајући нови снимак (и комит).

.Спајање ради интеграције разгранате историје рада
image::images/basic-rebase-2.png[Спајање ради интеграције разгранате историје рада]

Међутим, постоји још један начин: можете да узмете закрпу промене која је уведена у `C4` и да је поново примените преко `C3`.
У програму Гит се ово зове _ребазирање_.
`rebase` командом можете да узмете све промене које су комитоване у једну грану и да их поновите у некој другој.(((git commands, rebase)))

У овом примеру, одјавили бисте грану `experiment`, па је затим ребазирали преко `master` гране на следећи начин:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Ова операција функционише тако што оде на заједничког претка двеју грана (оне на којој се тренутно налазите и оне преко које ребазирате), узима разлику која је створена сваким комитом у грани на којој се налазите, чува те разлике у привремене фајлове, ресетује тренутну грану на исти комит на коме је и грана преко које ребазирате и коначно, редом примењује сваку промену.

.Ребазирање промена које су уведене у `C4` преко `C3`.
image::images/basic-rebase-3.png[Ребазирање промена које су уведене у `C4` преко `C3`.]

У овом тренутку можете да се вратите назад на `master` грану и да урадите спајање техником премотавања унапред.

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Премотавање `master` гране унапред.
image::images/basic-rebase-4.png[Премотавање `master` гране унапред.]

Сада је снимак на који показује `C4` потпуно исти као и онај на који је показивао `C5` у <<rebasing-merging-example,примеру спајања>>.
Нема разлике у крајњем производу интеграције, али ребазирањем се постиже чистија историја.
Ако истражите лог ребазиране гране, изгледа као линеарна историја: изгледа као да се сав рад одвијао серијски, иако су се ствари заправо одвијале паралелно.

Ово ћете често радити када желите се ваши комитови примене чисто на удаљену грану -- можда у пројекту којем желите да дате допринос, али који не одржавате.
У том случају, свој посао бисте радили у једној грани, па када будете спремни да пошаљете своје закрпе главном пројекту, ребазираћете свој рад преко `origin/master`. 
На овај начин, одржавалац не мора да ради никакав посебан посао око интеграције -- само треба да премота унапред или одради чисто примењивање.

Обратите пажњу на то да је завршни снимак на који показује коначни комит, било да је то последњи од ребазираних комитова у случају ребазирања, или коначни комит спајања након спајања, један те исти -- само се историја разликује.
Ребазирање понавља у некој другој све промене урађене у једној линији рада и то редом којим су прављене, док спајање узима крајње тачке и спаја их.

==== Интересантнији случајеви ребазирања

Ребазирање може да понови измене и над нечему другом, што није циљна грана ребазирања.
На пример, узмите историју као што је приказана на <<rbdiag_e>>.
Разгранали сте тематску грану (`server`) да бисте у свој пројекат додали неку функционалност са серверске стране, па направили комит.
Онда сте разгранали и од ње да бисте направили неке промене на клијентској страни (`client`), па комитовали неколико пута.
Коначно, вратили сте се на `server` грану и направили још неколико комитова.

[[rbdiag_e]]
.Историја са тематском граном разгранатом од друге тематске гране
image::images/interesting-rebase-1.png[Историја са тематском граном разгранатом од друге тематске гране]

Претпоставимо да сте одлучили да желите спојити ваше промене на клијентској страни са главном граном како би се објавиле, али желите да одложите промене на серверској страни док их боље не тестирате.
Можете да узмете промене са `client` гране које нису на `server` грани (`C8` и `C9`) и да их поновите преко `master` гране користећи опцију `--onto` команде `git rebase`:

[source,console]
----
$ git rebase --onto master server client
----

Ово у суштини каже „Провери грану `client`, одреди закрпе које су настале након што се одвојила од `server` гране, па их онда поново примени у грани `client` као да је уместо од `server` била одвојена директно од `master` гране”.
Мало је сложено, али резултат је одличан.

.Ребазирање тематске гране разгранате из друге тематске гране.
image::images/interesting-rebase-2.png[Ребазирање тематске гране разгранате из друге тематске гране.]

Сада можете да премотате унапред грану `master` (погледајте <<rbdiag_g>>):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rbdiag_g]]
.Премотавање `master` гране унапред тако да обухвати промене са гране
`client`
image::images/interesting-rebase-3.png[Премотавање `master` гране унапред тако да обухвати промене са гране]

Рецимо да сте одлучили да повучете и промене из `server` гране.
`server` грану можете да ребазирате преко `master` гране са `git rebase <основна_грана> <тематска_грана>` без потребе да је прво одјавите -- ова команда прво одјави тематску грану (у овом случају `server`) и примењује пронађене промене на основну грану `master`):

[source,console]
----
$ git rebase master server
----

Ovo ponavlja рад са `server` гране преко `master` гране, kao što se vidi na <<rbdiag_h>>.

[[rbdiag_h]]
.Ребазирање `server` гране преко `master` гране.
image::images/interesting-rebase-4.png[Ребазирање `server` гране преко `master` гране.]

Затим премотате унапред основну грану (`master`):

[source,console]
----
$ git checkout master
$ git merge server
----

Сада можете да обришете гране `client` и `server` јер је сав рад обављен на њима интегрисан и више вам неће бити потребне, а историја рада након овог процеса ће изгледати као на <<rbdiag_i>>:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rbdiag_i]]
.Коначна историја комитова
image::images/interesting-rebase-5.png[Коначна историја комитова]

[[_rebase_peril]]
==== Опасности ребазирања

(((rebasing, perils of)))
Ах, али блаженство ребазирања није без мана, што се може сумирати само једном реченицом:

*Не ребазирајте комитове који постоје ван вашег репозиторијума и на којима су људи можда засновали свој рад.*

Ако се држите ове смернице, све ће бити у реду.
У супротном ће вас људи мрзети, а породица и пријатељи ће вас презирати.

Када нешто ребазирате, ви напуштате постојеће комитове и стварате нове који су им слични, али су ипак другачији.
Ако комитове гурнете негде и остали их повуку, па базирају свој рад над њима, а ви затим поново напишете те комитове са `git rebase` и гурнете их поново, ваши сарадници ће морати да поново споје сав свој рад и онда ће настати хаос када пробате да повучете њихов рад назад у свој.

Pogledajmo primer koji pokazuje kako rebaziranje koje ste napravili javnim može da izazove probleme.
Pretpostavimo da ste napravili klon sa centralnog servera i onda radili nešto nad time.
Istorija komitova izgleda ovako:

.Kloniran repozitorijum nad kojim ste obavili neki posao.
image::images/perils-of-rebasing-1.png[Kloniran repozitorijum nad kojim ste obavili neki posao.]

Sada, neko drugi uradi još nekoliko stvari i uključi to u spoj, a zatim gurne sve na centralni server.
Vi to preuzmete i spojite novu udaljenu granu na ono što ste uradili, pa istorija izgleda nekako ovako:

.Preuzimanje drugih komitova i spajanje sa ličnim radom.
image::images/perils-of-rebasing-2.png[Preuzimanje drugih komitova i spajanje sa ličnim radom.]

Osoba koja je gurnula spojen rad zatim odluči da se vrati nazad i rebazira ono što je odradila; on ili ona uradi `git push --force` da bi se pisalo preko istorije na serveru.
Vi onda preuzmete sa tog servera, dovlačeći nove komitove.

[[_pre_merge_rebase_work]]
.Neko gurne rebazirane komitove, napuštajući komitove nad kojima ste bazirali vaš rad.
image::images/perils-of-rebasing-3.png["Neko gurne rebazirane komitove, napuštajući komitove nad kojima ste bazirali vaš rad."]

Sada ste oboje u neprilici.
Ako uradite `git pull`, napravićete spojni komit koji uključuje obe linije istorije, i repozitorijum će izgledati ovako:

[[_merge_rebase_work]]
.Ponovno spajanje istog rada u novi spojni komit.
image::images/perils-of-rebasing-4.png[Ponovno spajanje istog rada u novi spojni komit.]

Ako pokrenete `git log` dok vam istorija izgleda ovako, videćete dva komita koji imaju istog autora, vreme i poruku, što zna da zbunjuje.
Štaviše, ako gurnete ovu istoriju nazad na server, ponovo ćete uvesti sve te rebazirane komitove na centralni server, što će dalje zbunivati ljude.
Pretpostavlja se da drugi programer ne želi da se `C4` i `C6` nađu u istoriji; zato su uopšte i radi rebaziranje.

[[_rebase_rebase]]
==== Rebaziranje za rebaziranje

Ako se ipak nađete u ovakvoj situaciji, Git ima još neke čarolije koje vam mogu pomoći.
Ako neko iz tima nasilno gurne promene koje preklope ono nad čime ste vi bazirali svoj rad, izazov koji vam se nameće je da provalite šta je vaše a šta je on dodao.

Ispostavlja se da pored SHA-1 čeksume vezane za komit, Git računa i čeksumu koja je bazirana samo na zakrpi koja je uvedena sa komitom.
Ovo se zove "identifikacioni broj zakrpe".

Ako povučete rad koji je prepisan i rebazirate navrh toga sa novim komitovima vašeg partnera, Git često ume sam da provali šta je jedinstveno vaše i da primeni to nazad na vrh nove grane.

Na primer, u prethodnom scenariju, ako umesto spoja kada smo bili kod <<_pre_merge_rebase_work>> pokrenemo `git rebase teamone/master`, Git će:

* odrediti koji rad je jedinstven za našu granu (`C2`, `C3`, `C4`, `C6` i `C7`),
* odrediti šta nisu spojni komitovi (`C2`, `C3` i `C4`),
* odrediti šta nije prepisano u odredišnu granu (samo `C2` i `C3`, pošto je `C4` ista zakrpa kao i `C4'`) i
* primeniti te komitove na `teamone/master` granu.

Zato ćemo, umesto rezultata koji vidimo na <<_merge_rebase_work>>, dobiti nešto što više podseća na <<_rebase_rebase_work>>.

[[_rebase_rebase_work]]
.Rebaziranje na nasilno gurnuto rebaziranje.
image::images/perils-of-rebasing-5.png[Rebaziranje na nasilno gurnuto rebaziranje.]

Ovo će da upali samo ako `C4` i `C4'` koje je vaš partner napravio čine skoro identičnu zakrpu.
U suprotnom, rebaziranjem neće moći da se ustanovi da je to duplikat i biće dodata još jedna zakrpa koja podseća na `C4` (koja verovatno neće uspeti da se čisto primeni, jer će promene već bar delimično biti tamo).

Ovo možete da uprostite i pokretanjem `git pull --rebase` umesto običnog `git pull`.
Ili možete da uradite to ručno sa `git fetch` za kojim sledi `git rebase teamone/master` u ovom slučaju.

Ako koristite `git pull` i želite da `--rebase` bude podrazumevana opcija, možete da podesite `pull.rebase` vrednost iz konfiguracionog fajla na `true` sa `git config --global pull.rebase true`.

Ako rebaziranje posmatrate kao način da pospremite i radite sa komitovima pre nego što ih gurnete, i ako samo rebazirate komitove koji nikad nisu bili dostupni javno, sve će biti u redu.
Ako rebazirate komitove koji su već gurnuti javno, i ljudi baziraju svoj rad nad tim komitovima, onda ćete se naći u frustrirajućim situacijama i bićete meta prezira svojih saradnika.

Ako vi ili partner u nekom trenutku shvatite da je ovakav sled događaja neophodan, postarajte se da svi znaju da treba da pokrenu `git pull --rebase` da probaju da učine stvar barem malo jednostavnijom.

==== Rebaziranje protiv spajanja

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Sada kada ste videli kako deluje rebaziranje a kako spajanje, možda se pitate šta je bolje.
Pre nego što damo odgovor na ovo, hajde da načinimo korak unazad i popričamo malo o tome šta je zapravo istorija.

Jedna tačka gledišta na ovo je to da je istorija komitova vašeg repozitoijuma *zapis onoga što se zapravo dogodilo*.
To je istorijski dokument, vredan na svoj način, i ne bi trebalo da se čačka.
Iz ovog ugla, menjanje istorije komita je skoro pa bogohuljenje; vi _lažete_ o onome što se zapravo dogodilo.
Šta onda raditi kada se dogodi serija zbrkanih komitova?
Tako su se stvari dogodile, i repozitorijum treba da sačuva to za potomstvo.

Suprotna tačka gledišta je da je istorija komitova *priča o tome kako je projekat napravljen.*
Ne biste objavili prvu skicu knjige, a upustvo za održavanje softvera zaslužuje brižljivo redigovanje.
Ovaj tabor koristi alate kao što je rebaziranje i filter grane da bi ispričao priču onako kako je najbolje da je pročita budući čitalac.

Sada, što se tiče pitanja da li je spajanje ili rebaziranje bolje: nadamo se da ćete videti da stvari nisu tako jednostavne.
Git je moćan alat, dopušta vam da uradite mnoge stvari sa istorijom, ali svaki tim i svaki projekat je drugačiji.
Sada kada znate kako obe ove stvari rade, na vama je da odlučite šta je bolje za vašu konkretnu situaciju.

U opštem slučaju, najbolji način da iskoristite prednost oba sveta je da rebazirate lokalne promene koje ste napravili ali još niste podelili pre nego što ih gurnete kako biste očistili istoriju, ali da nikad ne rebazirate ništa što ste negde gurnuli.
