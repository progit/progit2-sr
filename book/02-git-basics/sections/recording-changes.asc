=== Snimanje promena na repozitorijumu

Сада имате _пристојан_ Гит репозиторијум и одјављене (тј. _радне копије)_ све фајлове тог пројекта.
Треба да направите неке измене и комитујете снимке тих измена у ваш репозиторијум сваки пут када пројекат досегне стање које желите да забележите.

Упамтите да сваки фајл у вашем радном директоријуму може бити у једном од два стања: праћен или непраћен (_tracked_ или _untracked_).
Праћени фајлови су фајлови који су били у последњем снимку; они могу да буду неизмењени, измењени или стејџовани.
Укратко, праћени фајлови су сви фајлови о којима програм Гит води рачуна.

Непраћени фајлови су све остало -- било који фајлови у радном директоријуму који нису били у последњем снимку и нису на стејџу.
Када први пут клонирате репозиторијум, сви фајлови ће бити праћени и неизмењени јер сте их је програм Гит управо одјавио и ви још увек нисте било шта изменили.

Како будете уређивали фајлове, програм Гит ће приметити да су измењени, јер сте их променили у односу на стање од последњег комита.
Док радите, ове измењене фајлове ћете селективно стејџовати и онда ћете комитовати све стејџоване промене, и циклус се понавља.

.Животни циклус статуса фајлова.
image::images/lifecycle.png[Животни циклус статуса фајлова.]

[[_checking_status]]
==== Провера статуса фајлова

Главни алат који користите да бисте сазнали који фајлови су у ком стању је команда `git status`.(((git commands, status)))
Ако покренете ову команду директно после клонирања, видећете нешто овако:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
----

Ово значи да имате чист радни директоријум - другим речима, ниједан од ваших праћених фајлова није измењен.
Гит такође не види никакве непраћене фајлове, иначе би били излистани овде.
Коначно, команда вам каже на којој се грани налазите и информише вас да није одвојила од исте гране на серверу.
Засад, грана ће увек бити `master`, што је подразумевано; овде не треба да се бринете о томе.
<<_git_branching>> ће детаљније размотрити гране и референце.

Рецимо да у пројекат додате нови фајл, обичан `README` фајл.
Ако фајл није постојао раније, а ви покренете `git status`, видећете свој непраћени фајл на следећи начин:

[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

Овде видите да је ваш нови `README` фајл непраћен, јер је у извештају под насловом „`Untracked files`”.
Непраћено у суштини значи да програм Гит види фајл који нисте имали у претходном снимку (комиту); програм Гит га неће укључити у комитоване снимке док му ви експлицитно не наредите тако.
Ради овако да не бисте случајно почели да додајете генерисане бинарне фајлове или друге фајлове које нисте намеравали да додате.
Пошто желите да почнете праћење фајла `README`, хајде да то и урадимо.

[[_tracking_files]]
==== Праћење нових фајлова

Да бисте почели да пратите нов фајл, можете да употребите команду `git add`.(((git commands, add)))
Праћење `README` фајла почиње након покретања ове команде:

[source,console]
----
$ git add README
----

Ако поново покренете команду `status`, видећете да је ваш `README` фајл сада праћен и стејџован за комит:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

----

Види се да је фајл стејџован јер је под насловом „`Changes to be committed`”.
Ако сада комитујете, верзија фајла у тренутку када сте покренули `git add` команду је оно што ће се наћи у историјском снимку.
Можда се сећате да када сте раније покренули `git init`, затим покренули и команду `git add <фајлови>` -- то је било потребно да бисте почели да пратите фајлове у вашем директоријуму.(((git commands, init)))(((git commands, add)))
Команда `git add` као аргумент узима име путање до фајла или директоријума; ако је директоријум, онда команда рекурзивно додаје све фајлове у том директоријуму.

==== Стејџовање модификованих фајлова

Хајде да променимо фајл који је већ праћен.
Ако промените фајл `CONTRIBUTING.md` који се од раније прати, па онда поново покренете команду `git status`, добићете нешто овако:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Фајл `CONTRIBUTING.md` се појављује под насловом „`Changes not staged for commit`” -- што значи да је фајл који је праћен сада измењен у радном директоријуму, али још увек није на стејџу.
Да бисте га стејџовали, покрените команду `git add`.
`git add` је команда за више намена - можете да је користите за праћење нових фајлова, за стејџовање фајлова, као и за друге ствари као што је обележавање да су конфликти код фајлова до којих је дошло приликом спајања разрешени.
Корисно је да о наредби размишљате као „додај тачно овај садржај у следећи комит”, а не као „додај овај фајл у пројекат”.(((git commands, add)))
Покренимо сада `git add` да стејџујемо фајл `CONTRIBUTING.md`, а онда поново покренимо `git status`:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

Оба фајла су сада стејџована и спремна за следећи комит.
У овом тренутку, претпоставимо да сте се сетили још једне мале измене у `CONTRIBUTING.md` пре него што сте га комитовали.
Отварате фајл и правите ту измену, и сада сте спремни за комит.
Ипак, хајде да покренемо `git status` још једном:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Шта је сад ово ког ђавола?
`CONTRIBUTING.md` је наведен у стејџованим _и_ у нестејџованим фајловима.
Како је то могуће?
Испоставља се да Гит стејџује фајл баш у тренутку када покренете команду `git add`.
Ако комитујете сада, верзија `CONTRIBUTING.md` која је била када сте покренули команду `git add` ће ући у комит, а не верзија која се налази у радном директоријуму када се покрене `git commit`.
Ако фајл измените након покретања команде `git add`, морате поново да покренете `git add` како бисте стејџовали последњу верзију фајла:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== Кратки статус

Мада је излаз команде `git status` прилично свеобухватан, такође је доста речит.
Програм Гит има и заставицу за кратки статус тако да промене можете прегледати у компактнијем облику.
Ако покренете команду `git status -s` или `git status --short` добијате много простији излаз:

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

Уз нове фајлови који се не прате стоји `??`, уз нове фајлове који су додати на стејџ стоји `A` (_added_), уз измењене фајлове стоји `M` (_modified_) и тако даље.
Постоје две колоне у испису - лева колона наводи статус стејџовања, а десна колона статус радног стабла.
У горњем примеру, фајл `README` je измењен у радном директоријуму, али још увек није stejdžovan, док је фајл `lib/simplegit.rb` измењен и стејџован.
Фајл `Rakefile` је измењен, стејџован, па затим поново измењен, тако да постоје промене које су стејџоване, али и оне које нису.

[[_ignoring]]
==== Игнорисање фајлова

Често ћете имати неку групу фајлова коју не желите да програм Гит аутоматски додаје, па чак ни да вам их приказује као непраћене.
То су обично аутоматски генерисани фајлови као што су логови или фајлови које генерише ваш систем за изградњу.
У тим случајевима, можете да направите обрасце за испис листе фајлова који ће се поредити и ставити их у  фајл под именом `.gitignore`.(((ignoring files)))
Ево примера `.gitignore` фајла:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

Прва линија налаже програму Гит да игнорише све фајлове који се завршавају на `.o` или `.a` - објектне и архивне фајлове који могу бити производ изградње вађег кода.
Друга линија налаже програму Гит да игнорише све фајлове који се завршавају тилдом (`~`), коју користе многи едитори текста као што је Emacs за обележавање привремених фајлова.
Можете да укључите и log, tmp или pid директоријум; аутоматски генерисану документацију; и тако даље.
Постављање `.gitignore` фајла пре него што кренете са радом је генерално добра идеја јер тако нећете случајно да комитујете фајлове које не желите у свом Гит репозиторијуму.

Правила за обрасце (шаблоне) које можете да ставите у `.gitignore` фајл су следећа:

*  ignorišu се prazne linije i linije koje počinju sa `#`,
*  функционишу standardni _glob_ obrasci и примењиваће се рекурзивно по целом радном стаблу,
*  обрасце можете da počnete kosom crtom (`/`) ако желите da izbegnete rekurziju,
*  обрасце možete da završite kosom crtom (`/`) ако наводите директоријум,
*  obrazac možete da negirate tako što ćete ga početi znakom uzvika (`!`).

_Glob_ обрасци су као поједностављени регуларни изрази које користе командна окружења.
Звездица (`*`) хвата један или више каратера; `[abc]` хвата сваки карактер у великим заградама (у овом случају a, b или c); знак питања (`?`) хвата један карактер; а велике заграде у којима се налазе карактери развојени цртицом (`[0-9]`) хватају било који карактер између њих (у овом случају од 0 до 9).
Можете да користите и две звездице за хватање угњеждених директоријума; `a/**/z` би хватало `a/z`, `a/b/z`, `a/b/c/z`, и тако даље.

Ево још једног примера `.gitignore` фајла:

[source]
----
# игнориши све .a фајлове
*.a

# али прати lib.a, мада се изнад игноришу сви .a фајлови
!lib.a

# игнориши само TODO фајлове у текућем директоријуму, а не и у поддир/TODO
/TODO

# игнориши све фајлове у build/ директоријуму
build/

# игнориши doc/notes.txt, али не и doc/server/arch.txt
doc/*.txt

# игнориши све .pdf фајлове у doc/ директоријуму (и његовим поддиректоријумима)
doc/**/*.pdf
----

[TIP]
====
Ако вам је потребна добра почетна тачка за ваш пројекат, _GitHub_ одржава прилично свеобухватну листу добрих `.gitignore` примера фајлова за гомилу пројеката и језика на
https://github.com/github/gitignore[].
====

[NOTE]
====
У простом случају, репозиторијум би могао да има један `.gitignore` фајл у свом кореном директоријуму који се рекурзивно примењује на цео репозиторијум.
Међутим, могуће је да у поддиректоријумима постоје и додатни `.gitignore` фајлови.
Правила у овим угњежденим `.gitignore` фајловима се примењују само на директоријум у коме се налазе.
Репозиторијум изворног кода Линукс језгра има 206 `.gitignore` фајлова.

Детаљи у вези вишеструких `.gitignore` фајлова излазе ван оквира ове књиге; ако сте заинтересовани, погледајте `man gitignore`.
====

[[_git_diff_staged]]
==== Gledanje stejdžovanih i nestejdžovanih promena

Ako vam je komanda `git status` previše nejasna -- želite da znate tačno šta ste promenili, ne samo fajlove koje ste promenili - možete da koristite komandu `git diff`.(((git commands, diff)))
Kasnije ćemo pokriti `git diff` malo detaljnije, ali verovatno ćete je najčešće koristiti da biste odgovorili na ova dva pitanja:
Šta ste promenili ali još niste stejdžovali?
I šta ste stejdžovali što ćete uskoro komitovati?
Dok `git status` odgovara na ova pitanja veoma opšte tako što vam daje imena fajlova, `git diff` pokazuje tačne linije koje su dodate i uklonjene -- kao da je zakrpa.

Recimo da editujete i stejdžujete `README` fajl ponovo i onda promenite fajl `CONTRIBUTING.md` ali ga ne stejdžujete.
Ako pokrenete komandu `git status`, ponovo ćete videti nešto ovako:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Da biste videli šta se promenili ali još niste stejdžovali, ukucajte `git diff` bez drugih argumenata:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

Ova komanda poredi šta se nalazi u vašem radnom direktorijumu sa onim što je na stejdžu.
Rezultat su promene koje ste promenili a još niste stejdžovali.

Ako želite da vidite šta ste stejdžovali, tj. šta će ući u sledeći komit, možete koristiti `git diff --staged`.
Ova komanda poredi stejdžovane promene sa poslednjim komitom:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

Bitno je da obratite pažnju na to da `git diff` sam po sebi ne prikazuje sve promene koje ste napravili od poslednjeg komita -- samo promene koje su još uvek nestejdžovane.
Ovo može biti zbunjujuće, jer ako ste stejdžovali sve promene, `git diff` vam neće vratiti ništa.

Kao drugi primer, recimo da ste stejdžovali fajl `CONTRIBUTING.md` i onda ga editovali; sada možete iskoristiti `git diff` da vidite promene u fajlu koje su stejdžovane i promene koje su nestejdžovane.
Ako naše okruženje izgleda ovako kao u donjem isečku,

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

možete iskoristiti `git diff` da vidite šta je nestejdžovano

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

i `git diff --cached` da vidite šta ste dosad stejdžovali (`--staged` i `--cached` su sinonimi):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
.Gitov _diff_ kao eksterni alat
====
Nastavićemo da koristimo komandu `git diff` na razne načine kroz ostatak ove knjige. Postoji još jedan način da se pogledaju ove razlike ako preferirate grafički ili eksterni program za pregled razlika. Ako pokrenete `git difftool` umesto `git diff`, moći ćete da vidite ove razlike u softeru kao što je _emerge_, _vimdiff_ i mnogim drugim (uključujući i komercijalne proizvode). Pokrenite `git difftool -tool-help` da vidite šta je dostupno za vaš sistem.
====

[[_committing_changes]]
==== Komitovanje promena

Sada kad je stejdž namešten onako kako želite, možete da komitujete svoje promene.
Upamtite da sve što još uvek nije stejdžovano -- svi fajlovi koje ste kreirali ili modifikovali a niste pokrenuli `git add` nad njima od trenutka kada ste ih editovali -- neće biti uključeni u ovaj komit.
Oni će ostati kao modifikovani fajlovi na disku.
U ovom slučaju, recimo da ste poslednji put kada ste pokrenuli `git status` videli da je sve stejdžovano, što znači da ste spremni da komitujete promene.(((git commands, status)))
Najjednostaniji način da komitujete je da ukucate `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Kada uradite to, pokrenuće se editor koji ste izabrali.
(Ovo je podešeno na osnovu promenljive okruženja `$EDITOR` u vašem šelu - obično _vim_ ili _emacs_, mada možete da ga konfigurišete na šta god poželite pomoću komande `git config --global core.editor` kao što ste videli u <<_getting_started>>).(((editor, changing default)))(((git commands, config)))

Editor prikazuje sledeći tekst (ovaj primer koristi editor _Vim_):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

Vidite da podrazumevana komit poruka sadrži iskomentarisani poslednji izlaz komande `git status` i jednu praznu liniju na vrhu.
Možete da obrišete ove komentare i upišete svoju poruku, ili možete da ih ostavite da bi vam pomogli da se prisetite šta komitujete.
(Za još eksplicitniji podsednik onoga što ste modifikovali, možete da prosledite opciju `-v` komandi `git commit`.
To će ubaciti razliku vaših promena u editor da biste mogli da vidite šta tačno komitujete.)
Kada izađete iz editora, Git pravi vaš komit sa tom komit porukom (sa izbačenim komentarima i razlikom).

Alternativno, možete da ukucate komit poruku u _inline_ modu sa komandom `commit` tako što ćete je specificirati nakon zastavice `-m`, na sledeći način:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Sada ste napravili svoj prvi komit! Vidite da vam je komit dao neki izlaz o sebi: na kojoj ste grani komitovali (`master`), koju SHA-1 kontrolnu sumu ima komit (`463dc4f`), koliko fajlova je promenjeno, i statistiku o linijama koje su dodate i obrisane u komitu.

Upamtite da komit čuva snimak koji ste postavili na stejdž. Sve što niste stejdžovali i dalje stoji tamo modifikovano; možete da uradite još jedan komit da dodate to u istoriju. Svaki put kada uradite komit, pravite snimak projekta u tom stanju da biste kasnije mogli da se vratite na njega ili da ga poredite sa tim.

==== Preskakanje stejdža

(((staging area, skipping)))
Premda može biti veoma korisno da komitujete stvari tačno onako kako želite, stavljanje na stejdž ponekad ume da bude malo kompleksnije od onoga što želite da uradite.
Ako želite da preskočite stejdž, Git nudi jednostavnu prečicu.
Dodavanjem opcije `-a` komandi `git commit`, nalažete Gitu da automatski stejdžuje svaki fajl koji je već praćen pre nego što je urađen komit, što vam omogućava da preskočite deo `git add`:

[source,console]
----
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Obratite pažnju na to da na ovaj način niste morali da pokrenete `git add` za `CONTRIBUTING.md` fajl pre nego što ste komitovali.

[[_removing_files]]
==== Uklanjanje fajlova

(((files, removing)))
Da biste uklonili fajl iz Gita, morate da ga uklonite iz praćenih fajlova (tačnije, da ga sklonite sa stejdža) i onda komitujete.
Komanda `git rm` radi to, i ona takođe uklanja fajl iz radnog direktorijuma kako ga ne biste videli među nepraćenim fajlovima sledeći put.

Ako samo uklonite fajl iz radnog direktorijuma, pojavljuje se pod "_Changed but not updated_" (odnosno, _nestejdžovani_) u izlazu komande `git status`.

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Ako onda pokrenete `git rm`, stejdžujete brisanje fajla:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

Sledeći put kada komitujete, fajl će nestati i više neće biti praćen.
Ako ste modifikovali fajl i već ga dodali u indeks, morate da primorate brisanje opcijom `-f`.
Ovo je sigurnosna mera koja obezbeđuje da slučajno ne obrišete podatke koji još nisu sačuvani u snimku, jer takve Git ne može da vam vrati natrag.

Još jedna korisna stvar koju ćete možda želeti da uradite je da zadržite fajl u radnom stablu ali da ga obrišete sa stejdža.
Drugim rečima, možda želite da zadržite fajl na hard disku ali ne želite da ga Git više prati.
Ovo je posebno korisno ako ste zaboravili da dodate nešto u fajl `.gitignore` i slučajno ga stejdžovali, kao što je veliki log fajl ili gomila kompajliranih `.a` fajlova.
Da biste uradili ovo, koristite `--cached` opciju:

[source,console]
----
$ git rm --cached README
----

Možete da prosleđujete fajlove, direktorijume i _file-glob_ obrasce komandi `git rm`.
To znači da možete da radite stvari kao:

[source,console]
----
$ git rm log/\*.log
----

Primetite naopaku kosu crtu (`\`) ispred `*`. Ovo je neophodno jer Git ima svoj _filename expansion_ koji se dodaje na _filename expansion_ vašeg šela.
Ova komanda uklanja sve fajlove koji imaju `.log` ekstenziju u `log/` direktorijumu.
Ili, još jedan koristan primer bi bio

[source,console]
----
$ git rm \*~
----

čime uklanjate sve fajlove koji se završavaju tildom.

[[_git_mv]]
==== Pomeranje fajlova

(((files, moving)))
Za razliku od mnogih drugih VCS sistema, Git ne prati pomeranje fajlova eksplicitno.
Ako promenite ime fajlu u Gitu, nikakvi metapodaci se ne čuvaju u Gitu koji vam govore da je fajl promenio ime.
Međutim, Git je prilično pametan što se tiče shvatanja toga nakon promene - malo ćemo se kasnije pozabaviti pomeranjem fajlova.

Imajući ovo u vidu, malo je konfuzno to što Git ima `mv` komandu. Ako želite da promenite ime fajlu u Gitu, možete da pokrenete nešto kao

[source,console]
----
$ git mv file_from file_to
----

i radiće kako treba. Zapravo, ako pokrenete nešto tako i onda pogledate status, videćete da Git to smatra fajlom čije je ime promenjeno:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

Ipak, ovo je ekvivalentno izvršenju sledećih komandi:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git implicitno shvata da se radi o promeni imena fajlu, tako da nije važno da li ćete ime menjati na ovaj način ili sa `mv` komandom.
Jedina prava razlika je to što je `git mv` jedna komanda umesto tri -- udobnije je koristiti nju.
Štaviše, možete da koristite bilo koji alat da promenite ime fajlu, a da kasnije primenite `rm` i `add`, pre nego što komitujete.
