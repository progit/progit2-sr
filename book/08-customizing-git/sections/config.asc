[[_git_config]]
=== Конфигурисање програма Гит

(((гит команде, config)))
Као што сте укратко прочитали у <<ch01-getting-started#ch01-getting-started>>, конфигурациона подешавања програма Гит можете поставити командом `git config`.
Једна од првих ствари које сте подесили су били ваше име и мејл адреса:

[source,console]
----
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
----

Сада ћете научити још неколико занимљивих опција које можете подесити на овај начин како бисте којима програм Гит прилагођавате својим потребама.

Најпре кратак резиме: програм Гит користи низ конфигурационих фајлова којима одређује неподразумевано понашање које је по вашој вољи.
Прво место на коме програм Гит тражи ове вредности су у фајлу `[путања]/etc/gitconfig` и он садржи подешавања која се примењују на сваког корисника на систему и на све њихове репозиторијуме.
Ако команди `git config` проследите опцију `--system`, програм Гит ће вршити упис и читање из овог фајла.

Следеће место које програм Гит гледа је `~/.gitconfig` (или `~/.config/git/config`) фајл који је посебан за сваког корисника.
Прослеђивањем опције `--global`, програм Гит можете приморати да чита и пише одавде.

И на крају, програм Гит гледа конфигурационе вредности у конфигурационом фајлу у Гит директоријуму (`.git/config`) оног репозиторијума који тренутно користите.
Ове вредности су одређене само за тај један репозиторијум и на њих реферишете прослеђивањем опције `--local` команди `git config`.
Ако не наведете ниво са којим желите да радите, ово је подразумевани.

Сваки од ових „нивоа” (системски, глобални, локални) пише преко вредности из претходног нивоа, што значи да ће, на пример, вредности у `.git/config` преиначити оне из `[путања]/etc/gitconfig`.

[NOTE]
====
Конфигурациони фајлови програма Гит се чувају као обичан текст, што значи да све вредности можете подесити и ручном изменом фајла, водећи рачуна о томе да синтакса буде исправна.
Ипак, у општем случају је једноставније извршити команду `git config`.
====

==== Основна конфигурација клијента

Конфигурационе опције које програм Гит препознаје се могу сврстати у две категорије: клијентске и серверске.
Већина опција је на страни клијента -- то су оне које подешавају личних радно окружење.
Подржано је много, _много_ конфигурационих опција, али велики део њих је користан само у одређеним крајњим случајевима.
Овде ћемо покрити само оне најчешће и најкорисније.
Ако желите да погледате листу свих опција које препознаје ваша верзија програма Гит, можете да извршите следећу команду:

[source,console]
----
$ man git-config
----

Ова команда приказује све доступне опције, прилично детаљно.
Овај референтни материјал можете наћи и на https://git-scm.com/docs/git-config[].

===== `core.editor`

((($EDITOR)))((($VISUAL, погледајте $EDITOR)))
Са подразумеваним подешавањима, програм Гит користи штагод постављено као подразумевани текст едитор преко једне од променљивих љуске `$VISUAL` или `$EDITOR`, а ако није постављена ниједна, користиће едитор `vi` за креирање и уређивање комит порука и порука ознака.
Ако желите да промените то подразумевано подешавање на нешто друго, можете да искористите подешавање `core.editor`:

[source,console]
----
$ git config --global core.editor emacs
----

Одсада, штагод да је у љуски подешено као подразумевани едитор, програм Гит ће покренути _Emacs_ за измену порука.

===== `commit.template`

(((комит шаблони)))
Ако подесите ово на путању до фајла у свом систему, програм Гит ће га користити као подразумевану почетну поруку када комитујете.
Вредност у креирању прилагођеног комит шаблона је што га можете употребити да подсетите себе (или друге) на правилан формат и стил када се креира комит порука.

На пример, рецимо да направите шаблон у фајлу `~/gitmessage.txt` који изгледа овако:

[source,text]
----
Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
----

Приметите како овај комит шаблон подсећа комитера да линију теме држи кратком (зарад излаза команде `git log --oneline`), да испод ње дода још детаља и да се позове на проблем или тикет баг трекера ако постоји.

Ако програму Гит желите рећи да ово користи као подразумевану поруку која се појављује у едитору када извршите `git commit`, треба да подесите конфигурациону вредност `commit.template`:

[source,console]
----
$ git config --global commit.template ~/.gitmessage.txt
$ git commit
----

Када комитујете, ваш едитор ће се отворити и приказати нешто овако на месту комит поруке:

[source,text]
----
Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C
----

Ако ваш тим има полису која управља форматом комит поруке, постављање шаблона за ту полису на систем и конфигурисање програма Гит да га подразумевано користи може помоћи да повећате шансе да се та полиса редовно поштује.

===== `core.pager`

(((pager)))
Ово подешавање одређује који пагинатор се користи када програм Гит дели излазе као што су `log` и `diff` на странице.
Можете да га поставити на `more` или на ваш омиљени пагинатор (подразумевано је `less`), или га можете искључити тако што ћете га поставити на празан стринг:

[source,console]
----
$ git config --global core.pager ''
----

Ако извршите ово, програм Гит ће излаз свих команди исписати одједном, без обзира на то колико су дугачки.

===== `user.signingkey`

(((GPG)))
Ако правите потписане прибележене ознаке (којима смо се бавили у <<ch07-git-tools#_signing>>) , постављање GPG кључа за потписивање као подешавање у конфигурацији ће учинити процес много једноставнијим.
Подесите ID свог кључа на следећи начин:

[source,console]
----
$ git config --global user.signingkey <gpg-key-id>
----

Ознаке сада можете да потпишете без потребе да сваки пут наводите кључ у `git tag` команди:

[source,console]
----
$ git tag -s <име-ознаке>
----

===== `core.excludesfile`

(((excludes)))(((.gitignore)))
У
`.gitignore`
фајл свог пројекта можете поставити шаблоне тако да их програм Гит не би видео као непраћене фајлове или покушао да их дода на стејџ када извршите `git add` над њима, као што смо видели у <<ch02-git-basics-chapter#_ignoring>>.

Али одређене фајлове понекада желите да игноришете у свим репозиторијума са којима радите.
Ако се на вашем компјутеру извршава мекОС, вероватно су вам познати `.DS_store` фајлови.  Ако је ваш омиљени едитор _Emacs_ или _Vim_, знате за имена фајлова које се завршавају са `~` или `.swp`.

Ово подешавање вам омогућава да напишете неку врсту глобалног `.gitignore` фајла.
Ако креирате фајл `~/.gitignore_global` са следећим садржајем:

[source,ini]
----
*~
.*.swp
.DS_Store
----

…и извршите `git config --global core.excludesfile ~/.gitignore_global`, програм Гит вам никад више неће правити проблеме са тим фајловима.

===== `help.autocorrect`

(((autocorrect)))
Ако погрешно укуцате команду, програм Гит вам показује нешто слично овоме:

[source,console]
----
$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

The most similar command is
    checkout
----

Програм Гит се труди да вам помогне тако што покушава да одреди коју сте команду желели да укуцате, али ипак одбија да је изврши.
Ако `help.autocorrect` поставите на `1`, програм Гит ће вам аутоматски покренути ову команду:

[source,console]
----
$ git chekcout master
WARNING: You called a Git command named 'chekcout', which does not exist.
Continuing under the assumption that you meant 'checkout'
in 0.1 seconds automatically...
----

Обратите пажњу на „0.1 seconds”.
`help.autocorrect` је уствари цео број који представља десетинке.
Ако га подесите на 50, програм Гит ће вам оставити пет секунди да се предомислите пре него што изврши команду коју је аутоматски исправио.

==== Боје у програму Гит

(((color)))
Програм Гит у потпуности подржава обојени излаз терминала, што доста помаже у бржем и лакшем визуелном парсирању излаза команде.
Постоји велики број опција које ће вам помоћи да боје подесите у складу са својим потребама.

===== `color.ui`

Програм Гит аутоматски боји већину свог исписа, али постоји главни прекидач који можете искористити уколико вам се овакав начин приказа не допада.
Ако желите да искључите сав обојени излаз програма Гит на терминалу, урадите следеће:

[source,console]
----
$ git config --global color.ui false
----

Подразумевано подешавање је `auto` и тада се излаз боји када се исписује директно на терминал, али не садржи контролне кодове боја када се излаз преусмерава у пајп или фајл.

Можете га поставити и на `always` ако желите да се не прави разлика између терминала и пајпова.
Ово ћете ретко користити; у већини случајева, ако желите кодове за боје у преусмереном излазу, можете уместо тога Гит команди да проследите заставицу `--color` чиме је приморавате да користи и кодове за боје.
Подразумевано подешавање је скоро увек оно што ће вам одговарати.

===== `color.*`

Ако желите да будете одређенији о томе које команде ће бити обојене и на који начин, програм Гит нуди посебна подешавања за боје.
Свака од ових се може подесити на `true`, `false` или `always`.

  color.branch
  color.diff
  color.interactive
  color.status

Сем тога, свака од ових има под-подешавања које можете употребити да поставите боју за делове излаза, ако желите да преиначите сваку боју.
На пример, да у `diff` излазу мета информација буде исписана плавим словима на црној позадини, подебљаним словима, можете да извршите следеће:

[source,console]
----
$ git config --global color.diff.meta "blue black bold"
----

Боју можете да подесите на било коју од следећих вредности: `normal` (како је подешен терминал), `black` (црна), `red` (црвена), `green` (зелена), `yellow` (жута), `blue` (плава), `magenta` (магента), `cyan` (тиркизна), или `white` (бела).
Ако желите да додате и атрибут као што је _bold_ у претходном примеру, можете да изаберете неки од следећих: `bold` (подебљано), `dim` (пригушено), `ul` (подвучено), `blink` (трепери) и `reverse` (замена боје текста и боје позадине).

[[_external_merge_tools]]
==== Спољни алати за спајање и приказ разлика

(((mergetool)))(((difftool)))
Мада програм Гит има своју унутрашњу имплементацију програма _diff,_ коју смо досад показивали у овој књизи, уместо њега можете да подесите и спољни алат.
Можете да подесите и графички алат за разрешење конфликта при спајању, уместо да их ручно решавате.
Приказаћемо подешавање _Perforce Visual Merge Tool_ (P4Merge) за приказ разлика и решавање конфликата при спајању, пошто је добар графички алат и бесплатан је.

Ако желите да пробате ово, _P4Merge_ ради на свим већим платформама и требало би да успете да га подесите.
Надаље ћемо користити имена путањи које раде на мекОС и Линуксу; за Виндоуз ћете морати да промените `/usr/local/bin` на путању до извршног фајла у свом окружењу.

За почетак, https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools[преузмите _P4Merge_ са _Perforce_ сајта].
Затим ћете подесити спољне омотач-скрипте које ће покретати команде.
Користићемо мекОС путању за извршни фајл; у другим системима, он ће бити тамо где је инсталиран `p4merge` бинарни фајл.
Подесите скрипту-омотач коју можете назвати `extMerge`, која зове бинарни фајл заједно са свим прослеђеним аргументима:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*
----

Омотач за приказ разлике проверава да ли је прослеђено седам аргумената и два од њих прослеђује скрипти за спајање.
Програм Гит подразумевано прослеђује следеће аргументе програму за приказ разлика:

[source]
----
path old-file old-hex old-mode new-file new-hex new-mode
----

Пошто су потребни само аргументи `old-file` и `new-file`, користимо скрипту-омотач да проследимо само оне који нам требају.

[source,console]
----
$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"
----

Такође је потребно и да дозволимо извршавање ових алата:

[source,console]
----
$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff
----

Сада можете подесити конфигурациони фајл тако да се за решавање конфликта и преглед промена користе алати које сте направили.
За то је потребно поставити већи број подешавања: `merge.tool` ће рећи програму Гит коју стратегију да користи, `mergetool.<алат>.cmd` наводи како се команда извршава, `mergetool.<алат>.trustExitCode` ће рећи програму Гит да ли излазни кôд програма говори о успешном решавању конфликта спајања или не, а `diff.external` ће рећи програму Гит коју команду да покрене за приказ промена.
Дакле, можете или да покренете четири команде за конфигурацију:

[source,console]
----
$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff
----

или да измените фајл `~/.gitconfig` тако да додате следеће линије:

[source,ini]
----
[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff
----

Када све ово подесите, ако извршите команду за преглед разлика као што је ова:

[source,console]
----
$ git diff 32d1776b1^ 32d1776b1
----

Уместо да добијете излаз разлике у командној линији, програм Гит покреће P4Merge, који изгледа отприлике овако:

.P4Merge
image::images/p4merge.png[P4Merge]

Ако пробате да спојите две гране и као последицу тога добијете конфликте при спајању, можете извршити команду `git mergetool`; она покреће P4Merge и дозвољава вам да решите конфликте у том ГКИ алату.

Добра ствар у вези ове поставке са омотачем је то што лако можете да промените алате за спајање и приказ разлика.
На пример, ако желите да промените алате `extDiff` и `extMerge` и подесите их тако да покрећу _KDiff3,_ све што треба да урадите је да уредите `extMerge` фајл:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*
----

Програм Гит ће сада користити алат _KDiff3_ за приказ промена и решавање конфликата при спајању.

Програм Гит се испоручује са великим бројем већ подешених осталих алата за разрешење конфликата при спајању за које не морате да подешавате конфигурацију из командне линије.
Ако желите да видите листу алата који су подржани, пробајте ово:

[source,console]
----
$ git mergetool --tool-help
'git mergetool --tool=<tool>' may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.
----

Ako програм _KDiff3_ ne želite da koristite za prikaz razlika, već samo za razrešenje konflikаta пти спајању, a komanda `kdiff3` се налази на вашиј путањи, možete извршити sledeće:

[source,console]
----
$ git config --global merge.tool kdiff3
----

Ако извршите ово уместо да подешавате фајлове `extMerge` и `extDiff`, програм Гит ће користити _KDiff3_ за разрешење конфликата, а за приказ разлика уобичајени интерни Гит алат намењен за то.

==== Форматирање и празан простор

(((празан простор)))
Проблеми са форматирањем и празним простором су неки од фрустрирајућих и суптилних проблема на које наилазе многи програмери који сарађују, поготово када не раде сви на истој платформи.
Веома је лако да закрпе и други производи рада на којем се сарађује доведу то неприметних промена у празном простору белине јер их едитори уводе без обавештавања, а ако вам фајлове икад дотакне Виндоуз систем, можда ће се заменити њихови крајеви линија.
Програм Гит има неколико конфигурационих опција које помажу код ових проблема.

===== `core.autocrlf`

(((crlf)))(((крајеви линија)))
Ако програмирате на Виндоузу и радите са људима који га не користе (или обрнуто), вероватно ћете у неком тренутку наићи на проблеме око крајева линија.
Разлог за ово је што Виндоуз у својим фајловима за прелом реда користи два карактера: и CR _(carriage-return)_ и LF _(linefeed)_ док мекОС и Линукс системи користе само карактер LF.
Ово је суптилна али изузетно фрустрирајућа чињеница рада на различитим платформама; многи едитори на Виндоузу без упозорења замењују постојеће крајеве редова у LF стилу са CRLF, или умећу оба карактера за прелом реда када корисник притисне тастер ентер.

Програм Гит ово може да обради аутоматским конвертовањем CRLF крајева линија у LF када додате фајл у индекс и обрнуто када одјављујете кôд у свој фајл систем.
Ову функционалност можете да укључити `core.autocrlf` подешавањем.
Ако сте на Виндоуз машини, подесите га на `true` -- то ће конвертовати све LF у CRLF
када одјављујете кôд:

[source,console]
----
$ git config --global core.autocrlf true
----

Ако сте на Линукс или мекОС систему који користи LF крајеве линија, онда не желите да их програм Гит аутоматски конвертује када одјављујете фајлове; међутим, ако се случајно уведе фајл са CRLF крајевима линија, онда бисте можда желели да програм Гит то аутоматски исправи.
Програму Гит можете рећи да конвертује CRLF у LF када комитујете, али не и обрнуто тако што ћете опцију `core.autocrlf` подесити на `input`:

[source,console]
----
$ git config --global core.autocrlf input
----

С оваквим подешавањем ћете имати CRLF крајеве линија у Виндоуз одјављивањима, али LF крајеве линија на мекОС и Линукс системима и у репозиторијуму.

Ако сте Виндоуз програмер који ради на искључиво Виндоуз пројекту, ову функционалност можете да искључите, чувајући и CR карактере у репозиторијуму тако што ћете конфигурациону вредност поставити на `false`:

[source,console]
----
$ git config --global core.autocrlf false
----

===== `core.whitespace`

Програм Гит може да открије и исправи неке од проблема са празним простором.
Може да пронађе шест основна проблема са празним простором -- три су подразумевано укључена и могу се искључити, а три су подразумевано искључена али се могу укључити.

Три која су подразумевано укључена су `blank-at-eol`, што тражи размаке не крају линије; `blank-at-eof`, што примећује празне редове на крају фајла; и `space-before-tab`, што тражи размаке испред табова на почетку линије.

Три подразумевано искључена која се могу укључити су `indent-with-non-tab`, што тражи линије које почињу размацима уместо табовима (и контролише се опцијом `tabwidth`); `tab-in-indent`, који надгледа табове у делу линије у којем је увлачење; и `cr-at-eol`, које говори програму Гит да су CR карактери на крајевима линија у реду.

Програму Гит наводите које од ових желите да укључите тако што ћете поставите `core.whietspace` на вредности које желите укључене или искључене, одвојене зарезима.
Опцију можете искључити тако што додате знак `-` испред вредности, или користите њену подразумевану вредност тако што је уопште ни не наведете у стрингу подешавања.
На пример, ако желите да укључите све осим `space-before-tab`, то можете урадити (уз то да је `trailing-space` скраћеница која покрива и `blank-at-eol` и `blank-at-eof`):

[source,console]
----
$ git config --global core.whitespace \
    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

Или можете да наведете само део који прилагођавате:

[source,console]
----
$ git config --global core.whitespace \
    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

Програм Гит ће ове проблеме открити када извршите команду `git diff` и пробаће да их обоји тако да их можда можете решити пре него што комитујете.
Такође ће користити ове вредности да вам помогне када примењујете закрпе командом `git apply`.
Када примењујете закрпе, од програма Гит можете затражити да вас упозори ако примењује закрпе које имају наведене проблеме са празним простором:

[source,console]
----
$ git apply --whitespace=warn <закрпа>
----

Или можете наредити програму Гит да покуша аутоматски да реши проблеме пре него што примени закрпу:

[source,console]
----
$ git apply --whitespace=fix <закрпа>
----

Ове опције се такође примењују и на команду `git rebase`.
Ако сте комитовали проблеме са празним простором, али их још нисте гурнули узводно, можете да извршите `git rebase --whitespace=fix` и програм Гит ће аутоматски да исправи проблеме до поново исписује закрпе.

==== Конфигурација сервера

За серверску страну програма Гит не постоји ни приближно оволико конфигурационих опција, али има неколико занимљивих који бисте можда желели да запамтите.

===== `receive.fsckObjects`

Програм Гит може обезбедити да се сваки објекат примљен током гурања и даље подудара са својом SHA-1 контролном сумом и показује на важеће објекте.
Ипак, он то подразумевано не ради; рачунање контролне суме је прилично скупа операција и може да успори извршавање, поготово на великим репозиторијума или при гурању велике количине података.
Ако желите да програм Гит проверава конзистентност објеката приликом сваког гурања, можете га приморати на то тако што ћете поставити `receive.fsckObjects` на `true`:

[source,console]
----
$ git config --system receive.fsckObjects true
----

Сада ће програм Гит проверити интегритет репозиторијума пре него што се свако гурање промена прихвати да би се обезбедило да неисправни (или злонамерни) клијенти не уносе неисправне податке.

===== `receive.denyNonFastForwards`

Ако ребазирате комитове које сте већ гурнули и онда покушате поново да их гурнете, или на неки други начин покушате да гурнете комит на удаљену грану који не садржи комит на који тренутно показује удаљена грана, та операција вам неће бити одобрена.
Ово је у општем случају добра полиса; али у случају ребазирања, можете одлучити да знате шта радите и својој команди гурања проследити заставицу `-f`, чиме принудно ажурирате удаљену грану.

Ако програму Git желите наложити da odbija принудна guranjа, poставите `receive.denyNonFastForwards`:

[source,console]
----
$ git config --system receive.denyNonFastForwards true
----

Други начин на који ово можете урадити на страни сервера јесте помоћу кука на серверској страни, што ћемо обрадити ускоро.
Такав приступ вам нуди могућност да урадите и неке сложеније ствари као што је одбијање спајања која не користе технику брзог премотавања унапред само одређеном подскупу корисника.

===== `receive.denyDeletes`

Један од начина да се заобиђе `denyNonFastForwards` полиса је да корисник обрише грану, па да је онда поново гурне узводно са новом референцом.
Да бисте и ово онемогућили, поставите `receive.denyDeletes` на `true`.

[source,console]
----
$ git config --system receive.denyDeletes true
----

Ово одбија било какво брисање грана или ознака -- то не може да ради ниједан корисник.
Ако желите да уклоните удаљене гране, морате ручно да обришете фајлове референци са сервера.
Такође постоје и занимљивији начини да се ово уради на нивоу корисника преко ACL листи, као што ћете научити у <<ch08-customizing-git#_an_example_git_enforced_policy>>.
